<!DOCTYPE html>
<!-- Made by Mike Bostock
http://bl.ocks.org/mbostock/3887118
-->
<meta charset="utf-8">
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<style>

/*  
What's all this?
*/

body {
  font: 10px sans-serif;
}

.axis line,
.axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.arrow {
  stroke: #000;
  stroke-width: 1.5px;
}

.outer,
.inner {
  shape-rendering: crispEdges;
}

.outer {
  fill: none;
  stroke: #000;
}

.inner {
  fill: #ccc;
  stroke: #000;
  stroke-dasharray: 3, 4;
}

</style>
<body>
<script src="http://d3js.org/d3.v2.min.js?2.9.5"></script>
<script>

// What's going on here?
// Bostock is setting a bunch of variables of height and width that's all relative to each other. This way he doesn't have to hard code any of the sizes anywhere else.

var margin = {top: 20, right: 20, bottom: 20, left: 20},
    padding = {top: 60, right: 60, bottom: 60, left: 60},
    outerWidth = 960,
    outerHeight = 500,
    innerWidth = outerWidth - margin.left - margin.right,
    innerHeight = outerHeight - margin.top - margin.bottom,
    width = innerWidth - padding.left - padding.right,
    height = innerHeight - padding.top - padding.bottom;



var x = d3.scale.identity()
    .domain([0, width]);
// What's this identify function?
// Scales are functions that map from an input domain to an output range. 
// Identity scales are a special case of linear scales where the domain and range are identical; the scale and its invert method are both the identity function. More often, you'll use d3.scale.linear or d3.scale.ordinal scales for your data. You'll see that in the scatterplot example we go through later.


// What's this domain?
// The domain says how far you can go. In your X axis, you'll use the width, and in the your Y axis, you'll use the height. The order here is important, and we'l see this more in the scatterplot - this is how you handle the inverted coordinate plane.

var y = d3.scale.identity()
    .domain([0, height]);

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

// What's the Axis() function?
// D3’s axis component displays reference lines for scales automatically. This lets you focus on displaying the data, while the axis component takes care of the tedious task of drawing axes and labeled ticks.

// If scale is specified, sets the scale and returns the axis. If scale is not specified, returns the current scale which defaults to a linear scale. Here we're using the x variable ot set the scale, which is based on the domain we set before.


// What's this orient function?
// This is says where we want to orient the Axis (for which side the ticks will apear)

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("right");

var svg = d3.select("body").append("svg")
    .attr("width", outerWidth)
    .attr("height", outerHeight)
  .append("g")
  // What's the <g> tag?
  // It's a way to group items together. It's a good way to set margins (below), and modify multiple items grouped together easily.

    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
// What's this translate function?

// We use attr() to apply transform as an attribute of g. SVG transforms are quite powerful, and can accept several different kinds of transform definitions, including scales and rotations. But we are keeping it simple here with only a translation transform, which simply pushes the whole g group over and down by some amount.
// Translation transforms are specified with the easy syntax of translate(x,y), where x and y are, obviously, the number of horizontal and vertical pixels by which to translate the element.

var defs = svg.append("defs");
// What's this for?
// Bostock is defining objects that we're going to use later. They're market objects, called either triangle start or triangle end. He appends them as markers with a path that's defining the triangle shape. It's an interesting method that you don't see that frequently.

defs.append("marker")
    .attr("id", "triangle-start")
    .attr("viewBox", "0 0 10 10")
    .attr("refX", 10)
    .attr("refY", 5)
    .attr("markerWidth", -6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M 0 0 L 10 5 L 0 10 z");

defs.append("marker")
    .attr("id", "triangle-end")
    .attr("viewBox", "0 0 10 10")
    .attr("refX", 10)
    .attr("refY", 5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("path")
    .attr("d", "M 0 0 L 10 5 L 0 10 z");


// What's this?
svg.append("rect")
    .attr("class", "outer")
    .attr("width", innerWidth)
    .attr("height", innerHeight);


// What's this for?
var g = svg.append("g")
    .attr("transform", "translate(" + padding.left + "," + padding.top + ")");

g.append("rect")
    .attr("class", "inner")
    .attr("width", width)
    .attr("height", height);

g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
//What's this call function?

// D3’s call() function takes a selection as input and hands that selection off to any function. So, in this case, we have just appended a new g group element to contain all of our about-to-be-generated axis elements. (The g isn’t strictly necessary, but keeps the elements organized and allows us to apply a class to the entire group)
// That g becomes the selection for the next link in the chain. call() hands that selection off to the xAxis function, so our axis is generated within the new g. 


g.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(" + width + ",0)")
    .call(yAxis);


// What are all these lines?
svg.append("line")
    .attr("class", "arrow")
    .attr("x2", padding.left)
    .attr("y2", padding.top);
    .attr("marker-end", "url(#triangle-end)");

svg.append("line")
    .attr("class", "arrow")
    .attr("x1", innerWidth / 2)
    .attr("x2", innerWidth / 2)
    .attr("y2", padding.top)
    .attr("marker-end", "url(#triangle-end)");

svg.append("line")
    .attr("class", "arrow")
    .attr("x1", innerWidth / 2)
    .attr("x2", innerWidth / 2)
    .attr("y1", innerHeight - padding.bottom)
    .attr("y2", innerHeight)
    .attr("marker-start", "url(#triangle-start)");

svg.append("line")
    .attr("class", "arrow")
    .attr("x2", padding.left)
    .attr("y1", innerHeight / 2)
    .attr("y2", innerHeight / 2)
    .attr("marker-end", "url(#triangle-end)");

svg.append("line")
    .attr("class", "arrow")
    .attr("x1", innerWidth)
    .attr("x2", innerWidth - padding.right)
    .attr("y1", innerHeight / 2)
    .attr("y2", innerHeight / 2)
    .attr("marker-end", "url(#triangle-end)");

// What's this stuff?
// Here, Bostock appends some things to explain what's going on in the visualization.
svg.append("text")
    .text("origin")
    .attr("y", -8);

svg.append("circle")
    .attr("class", "origin")
    .attr("r", 4.5);

g.append("text")
    .text("translate(margin.left, margin.top)")
    .attr("y", -8);

</script>
